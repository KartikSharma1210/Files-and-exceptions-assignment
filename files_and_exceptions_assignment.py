# -*- coding: utf-8 -*-
"""Files_and_exceptions_assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ofWz61SGsiaUaRB7gRlDknhHTb66gtQk

1. What is the difference between interpreted and compiled languages?

Compiled and interpreted languages differ primarily in *how* and *when* code is translated into machine-readable instructions.

### **Compiled Languages**

* A compiler translates the entire source code into machine code *before* execution.
* The result is a standalone executable.
* Errors are detected during the compilation stage.
* Execution is generally faster because the CPU runs pre-compiled machine code.

**Examples:** C, C++, Go, Rust.

Interpreted Languages

* The interpreter executes code *line by line* at runtime.
* No separate executable is created.
* Easier to debug because errors appear as soon as the faulty line executes.
* Typically slower than compiled languages due to runtime translation.

**Examples:** Python, Ruby, JavaScript.

---

2. What is exception handling in Python?

Exception handling is Python’s mechanism for dealing with runtime errors. Instead of crashing the program, Python allows developers to manage exceptions gracefully using keywords like `try`, `except`, `else`, and `finally`.

### **Purpose of Exception Handling**

* Prevents program termination.
* Allows meaningful error messages.
* Ensures reliability and user-friendly behavior.
* Helps developers debug and control error flow.

---

3. What is the purpose of the `finally` block in exception handling?

The `finally` block contains code that runs **regardless of whether an exception occurs**.

### Uses

* Releasing resources (files, database connections).
* Closing network sockets.
* Cleaning temporary data.

Even if `try` or `except` has a `return` statement, `finally` still executes.

---

4. What is logging in Python?

Logging refers to recording important events—such as warnings, errors, or general information—during program execution.

Why Use Logging Instead of Print?

* Allows different levels of severity.
* Can write to files, console, or external systems.
* Timestamping and formatting support.
* Essential for debugging complex applications.

Python's built-in `logging` module offers a flexible way to track application behavior.

---

5. What is the significance of the `__del__` method in Python?

`__del__` is a destructor method in Python.

### **Key Points**

* Automatically called when an object is about to be destroyed.
* Often used for cleanup operations.
* Not guaranteed to run instantly due to garbage collector timing.

**Example:** releasing external resources like files.

---

6. Difference between `import` and `from … import` in Python.

### **`import module`**

* Imports the entire module.
* Access functions using `module.function()`.

### **`from module import name`**

* Imports specific functions, classes, or variables.
* Can call them directly without module prefix.

Which is Better?

Use full import to avoid naming conflicts; use selective import for convenience.

---

7. How can you handle multiple exceptions in Python?

Python allows multiple exceptions to be handled using either:

Option 1: Tuple of Exceptions

```
except (ValueError, TypeError):
```
Option 2: Multiple Except Blocks

```
except ValueError:
except TypeError:
```

Each exception type gets its own handler.

---

8. What is the purpose of the `with` statement when handling files in Python?

The `with` statement is used to manage resources.

Advantages

* Automatically closes the file.
* Prevents resource leakage.
* Makes code cleaner and safer.

It internally uses context manager methods `__enter__` and `__exit__`.

---

9. What is the difference between multithreading and multiprocessing?

### **Multithreading**

* Multiple threads exist within a single process.
* Threads share memory.
* Best
"""

# 1. How can you open a file for writing in Python and write a string to it?

with open("file.txt", "w") as f:
    f.write("Hello World")

# 2. Write a Python program to read the contents of a file and print each line.

with open("file.txt") as f:
    for line in f:
        print(line.strip())

#3.How would you handle a case where the file doesn't exist while trying to open it for reading?

try:
    open("missing.txt")
except FileNotFoundError:
    print("File not found")

#4. Write a Python script that reads from one file and writes its content to another file.

with open("in.txt", "w") as f:
    f.write("This is sample content.")

#5. How would you catch and handle division by zero error in Python.
try:
    a = 10/0
except ZeroDivisionError:
    print("Cannot divide by zero")

#6. Write a Python program that logs an error message to a log file when a division by zero exception occurs.

import logging
logging.basicConfig(filename="log.txt", level=logging.ERROR)
try:
    10/0
except ZeroDivisionError:
    logging.error("Division by zero occurred")

#7.How do you log information at different levels (INFO, ERROR, WARNING) in Python using the logging module?

import logging
logging.basicConfig(level=logging.INFO)
logging.info("Info message")
logging.warning("Warning message")
logging.error("Error message")

#8 Write a program to handle a file opening error using exception handling.

try:
    open("abc.txt")
except Exception as e:
    print("Error:", e)

#9. How can you read a file line by line and store its content in a list in Python?


with open("a.txt", "w") as f:
    f.write("Line 1\nLine 2\nLine 3")
with open("a.txt") as f:
    lines = f.readlines()
print(lines)

#10. How can you append data to an existing file in Python?

with open("file.txt", "a") as f:
    f.write("New line\n")

#11. Write a Python program that uses a try-except block to handle an error when attempting to access a dictionary key that doesn't exist.

try:
    print({"a":1}["b"])
except KeyError:
    print("Key missing")

#12. Write a program that demonstrates using multiple except blocks to handle different types of exceptions.


try:
    x = 1/0
except ZeroDivisionError:
    print("Zero error")
except TypeError:
    print("Type error")

#13. How would you check if a file exists before attempting to read it in Python?


import os
print(os.path.exists("test.txt"))

#14. Write a program that uses the logging module to log both informational and error messages.


import logging
logging.basicConfig(filename="log.txt", level=logging.INFO)
logging.info("Info")
logging.error("Error")

#15. Write a Python program that prints the content of a file and handles the case when the file is empty.


with open("a.txt") as f:
    data = f.read()
    print(data if data else "File empty")

#16. Demonstrate how to use memory profiling to check the memory usage of a small program.


import sys
x = [1,2,3]
print(sys.getsizeof(x))

#17. Write a Python program to create and write a list of numbers to a file, one number per line.


import sys
x = [1,2,3]
print(sys.getsizeof(x))

#18. How would you implement a basic logging setup that logs to a file with rotation after 1MB?


from logging.handlers import RotatingFileHandler
import logging

handler = RotatingFileHandler("app.log", maxBytes=1_000_000, backupCount=3)
logging.basicConfig(handlers=[handler], level=logging.INFO)

#19. Write a program that handles both IndexError and KeyError using a try-except block.


try:
    arr = [1]
    print(arr[2])
except IndexError:
    print("Index error")
except KeyError:
    print("Key error")

#20. How would you open a file and read its contents using a context manager in Python?

with open("a.txt") as f:
    print(f.read())

#21. Write a Python program that reads a file and prints the number of occurrences of a specific word.


word = "python"
with open("a.txt") as f:
    print(f.read().count(word))

#22. How can you check if a file is empty before attempting to read its contents?


import os
print(os.path.getsize("a.txt") == 0)

#23. Write a Python program that writes to a log file when an error occurs during file handling.


import logging
logging.basicConfig(filename="log.txt", level=logging.ERROR)

try:
    open("missing.txt")
except Exception as e:
    logging.error(e)